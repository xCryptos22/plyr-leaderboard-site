<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PLYR Speedrun Leaderboard</title>
  <meta name="theme-color" content="#0B1020" />
  <!-- Inter (wie auf plyr.network) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        fontFamily: { sans: ['Inter','ui-sans-serif','system-ui'] },
        extend: {
          colors: {
            bg: { 900:'#0B1020', 800:'#101833', 700:'#121B3A' },
            brand: { 500:'#00D4FF', 600:'#00B7E0' },  /* Cyan von PLYR */
            accent:{ 500:'#9B8CFF', 600:'#7C6DFF' }   /* Violett von PLYR */
          },
          boxShadow: {
            glow: '0 10px 30px rgba(0,212,255,.18)',
            card: '0 1px 0 rgba(255,255,255,.04), 0 8px 30px rgba(0,0,0,.35)'
          },
          backdropBlur: { xs: '2px' }
        }
      }
    }
  </script>

  <style>
    :root{
      --plyr-bg:#0B1020;
      --plyr-card:rgba(255,255,255,.04);
      --plyr-border:rgba(255,255,255,.07);
      --plyr-cyan:#00D4FF;
      --plyr-violet:#9B8CFF;
    }
    html,body{background:var(--plyr-bg);}
    body{color:#e5e7eb; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto; }
    /* Glass/Glow & Gradient wie auf plyr.network */
    .glass{backdrop-filter:blur(10px);background:var(--plyr-card);border:1px solid var(--plyr-border)}
    .gradient-text{background:linear-gradient(90deg,var(--plyr-cyan),var(--plyr-violet));-webkit-background-clip:text;background-clip:text;color:transparent}
    .btn-primary{background:linear-gradient(90deg,var(--plyr-cyan),var(--plyr-violet));color:#0B1020;border:0}
    .btn-primary:hover{filter:brightness(1.05)}
    .btn-ghost{background:rgba(255,255,255,.04);border:1px solid var(--plyr-border)}
    .btn-ghost:hover{border-color:#64748b}
    .pill{background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.06);border-radius:9999px}
    .pill-active{box-shadow:0 0 0 1px var(--plyr-cyan) inset,0 0 20px rgba(0,212,255,.25);background:rgba(0,212,255,.12)}
    .thin-scrollbar{scrollbar-width:thin;scrollbar-color:#46506a transparent}
    .thin-scrollbar::-webkit-scrollbar{height:8px}
    .thin-scrollbar::-webkit-scrollbar-thumb{background:#46506a;border-radius:9999px}

    /* Dezente „Lichtflecken“ */
    .light-a,.light-b{position:absolute;border-radius:50%;pointer-events:none}
    .light-a{right:-18rem;top:-18rem;width:38rem;height:38rem;background:var(--plyr-cyan);filter:blur(120px);opacity:.12}
    .light-b{left:-14rem;bottom:-14rem;width:28rem;height:28rem;background:var(--plyr-violet);filter:blur(120px);opacity:.12}

    /* Tabelle */
    table thead th{font-weight:600;letter-spacing:.01em}
    tbody tr:hover td{background:rgba(255,255,255,.04)}
  </style>
</head>

<body class="min-h-screen bg-bg-900 selection:bg-brand-500/30">
  <!-- Nav -->
  <nav class="sticky top-0 z-40 bg-bg-900/70 backdrop-blur-xs border-b border-white/5">
    <div class="max-w-7xl mx-auto px-4 h-14 flex items-center justify-between">
      <div class="flex items-center gap-3">
        <div class="h-7 w-7 rounded-md bg-gradient-to-br from-brand-500 to-accent-600"></div>
        <span class="text-lg font-extrabold tracking-tight gradient-text">PLYR</span>
        <span class="ml-2 text-slate-400 hidden sm:inline">Speedrun Leaderboard</span>
      </div>
      <div class="flex items-center gap-2">
        <a id="explorerLink" target="_blank" class="btn-ghost px-3 py-1.5 rounded-lg transition">Explorer öffnen</a>
        <button id="reloadBtn" class="btn-ghost px-3 py-1.5 rounded-lg transition">Neu laden</button>
      </div>
    </div>
  </nav>

  <!-- Hero -->
  <header class="relative overflow-hidden">
    <div class="light-a"></div><div class="light-b"></div>
    <div class="max-w-7xl mx-auto px-4 py-8 md:py-12">
      <h1 class="text-3xl md:text-5xl font-extrabold leading-tight">
        <span class="gradient-text">PLYR Speedrun Leaderboard</span>
      </h1>
      <p class="text-slate-300 mt-2">
        NFT‑basierte Zeiten • gefiltert nach <span id="tokenName">Collection</span> • Contract
        <code id="contractShort" class="text-slate-400"></code>
      </p>
    </div>
  </header>

  <!-- Controls -->
  <section class="max-w-7xl mx-auto px-4">
    <div class="glass rounded-2xl p-4 md:p-6 shadow-glow">
      <div class="grid md:grid-cols-3 gap-4">
        <!-- Mapid -->
        <div>
          <label class="text-sm text-slate-300">Runde (mapid)</label>
          <div class="mt-1 flex items-center gap-2">
            <select id="mapSelect" class="w-full bg-bg-800 border border-slate-700 rounded-xl px-3 py-2 focus:outline-none focus:ring-2 focus:ring-brand-500"></select>
            <button id="prevMap" title="Vorherige Runde" class="px-3 py-2 rounded-lg bg-bg-800 border border-slate-700 hover:bg-slate-800">◀</button>
            <button id="nextMap" title="Nächste Runde" class="px-3 py-2 rounded-lg bg-bg-800 border border-slate-700 hover:bg-slate-800">▶</button>
          </div>
          <p class="text-xs text-slate-400 mt-1">Standard: vorletzte Runde</p>
        </div>

        <!-- Cointype Filter -->
        <div>
          <label class="text-sm text-slate-300">Währung (cointype)</label>
          <div id="coinFilter" class="mt-1 flex gap-2 overflow-x-auto thin-scrollbar pr-1 py-1"></div>
          <p class="text-xs text-slate-400 mt-1">Eigenes Board je Währung + Gesamt‑Board.</p>
        </div>

        <!-- Player search -->
        <div>
          <label class="text-sm text-slate-300">Spieler suchen</label>
          <div class="mt-1 flex items-center gap-2">
            <input id="playerSearch" placeholder="Name (ohne .plyr) oder Adresse" class="w-full bg-bg-800 border border-slate-700 rounded-xl px-3 py-2 focus:outline-none focus:ring-2 focus:ring-accent-600" />
            <button id="showPlayerBtn" class="btn-primary px-4 py-2 rounded-xl font-semibold">Anzeigen</button>
          </div>
          <p class="text-xs text-slate-400 mt-1">Tipp: Namen im Leaderboard anklicken für alle Zeiten.</p>
        </div>
      </div>
    </div>
  </section>

  <!-- Leaderboard -->
  <main class="max-w-7xl mx-auto px-4 mt-6 mb-24">
    <div class="glass rounded-2xl shadow-glow">
      <div class="flex items-center justify-between px-4 md:px-6 py-4 border-b border-white/5">
        <div>
          <h2 class="text-xl md:text-2xl font-bold">Leaderboard</h2>
          <p id="boardSubtitle" class="text-slate-400 text-sm"></p>
        </div>
        <div class="text-sm text-slate-400"><span id="totalRows">0</span> Einträge • <span id="loadedCount">0</span> NFTs geladen</div>
      </div>

      <div class="overflow-x-auto">
        <table class="min-w-full text-left">
          <thead class="bg-bg-800/60">
            <tr class="text-slate-300 text-sm">
              <th class="px-4 md:px-6 py-3">Platz</th>
              <th class="px-4 md:px-6 py-3">Spieler</th>
              <th class="px-4 md:px-6 py-3">Zeit</th>
              <th class="px-4 md:px-6 py-3">Währung</th>
              <th class="px-4 md:px-6 py-3">NFT</th>
            </tr>
          </thead>
          <tbody id="tableBody" class="divide-y divide-white/5"></tbody>
        </table>
      </div>

      <div id="loadMoreWrap" class="flex items-center justify-center py-6 hidden">
        <button id="loadMoreBtn" class="px-5 py-2 rounded-xl bg-bg-800 border border-slate-700 hover:bg-slate-800">Mehr laden…</button>
      </div>
    </div>
  </main>

  <!-- Player Modal -->
  <div id="playerModal" class="fixed inset-0 z-50 hidden">
    <div class="absolute inset-0 bg-black/70"></div>
    <div class="relative max-w-3xl mx-auto mt-16 glass rounded-2xl shadow-glow">
      <div class="flex items-center justify-between px-6 py-4 border-b border-white/5">
        <div>
          <h3 id="playerTitle" class="text-xl font-bold"></h3>
          <p id="playerSubtitle" class="text-slate-400 text-sm"></p>
        </div>
        <button id="closePlayer" class="px-3 py-2 rounded-lg bg-bg-800 border border-slate-700">Schließen</button>
      </div>
      <div class="p-4 md:p-6 max-h-[70vh] overflow-y-auto">
        <table class="min-w-full text-left">
          <thead class="bg-bg-800/60 text-slate-300 text-sm">
            <tr>
              <th class="px-4 md:px-6 py-2">Runde</th>
              <th class="px-4 md:px-6 py-2">Währung</th>
              <th class="px-4 md:px-6 py-2">Zeit</th>
              <th class="px-4 md:px-6 py-2">NFT</th>
            </tr>
          </thead>
          <tbody id="playerBody" class="divide-y divide-white/5"></tbody>
        </table>

        <div class="mt-6">
          <div class="flex items-center justify-between">
            <h4 class="text-lg font-semibold">Perk‑NFT</h4>
            <a id="perkLink" target="_blank" class="text-brand-300 hover:underline hidden">Zum NFT</a>
          </div>
          <div id="perkStatus" class="text-slate-400 text-sm mt-1"></div>
          <div id="perkWrap" class="mt-3 grid sm:grid-cols-2 md:grid-cols-3 gap-3"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Loading overlay -->
  <div id="loadingOverlay" class="fixed inset-0 pointer-events-none grid place-items-center">
    <div class="p-4 rounded-2xl bg-bg-800/85 border border-slate-700 shadow-xl">
      <div class="animate-spin h-6 w-6 border-2 border-slate-500 border-t-brand-500 rounded-full mx-auto"></div>
      <p class="text-sm text-slate-300 mt-2">Lade NFT‑Daten… <span id="progressText" class="text-slate-400"></span></p>
    </div>
  </div>

  <!-- === Original JavaScript aus deiner hochgeladenen Datei === -->
  <script>
tailwind.config = {
      theme: {
        extend: {
          colors: {
            bg: { 900: '#0B1020', 800: '#101833' },
            primary: { 500: '#6EE7F9', 600: '#22D3EE' },
            accent: { 500: '#A78BFA', 600: '#8B5CF6' }
          },
          boxShadow: { glow: '0 10px 30px rgba(110,231,249,0.2)' }
        }
      }
    }
  


  ;(() => {
    const API_BASE = 'https://explorer.plyr.network'
    const CONTRACT = '0x5c8b153c2451010aA074b4387Ec3573cFb547531'.toLowerCase()
    const PERK_CONTRACT = '0xa6b69deDd6c0c333CE34b2564aaCBCB7616a6dd1'.toLowerCase()
    const ZERO = '0x0000000000000000000000000000000000000000'

    // ------------------ State ------------------
    const state = {
      items: [],          // All NFT instances (raw)
      mapids: new Set(),  // All mapids discovered
      coins: new Set(),   // All cointypes discovered
      nextUrl: null,      // Next page URL if any
      baseListUrl: null,  // Base URL for building next page URLs
      selectedMap: null,
      selectedCoin: 'ALL',
    }

    // ------------------ UI Refs ------------------
    const contractShort = document.getElementById('contractShort')
    const explorerLink  = document.getElementById('explorerLink')
    const mapSelect     = document.getElementById('mapSelect')
    const prevMapBtn    = document.getElementById('prevMap')
    const nextMapBtn    = document.getElementById('nextMap')
    const coinFilter    = document.getElementById('coinFilter')
    const boardSubtitle = document.getElementById('boardSubtitle')
    const tableBody     = document.getElementById('tableBody')
    const totalRows     = document.getElementById('totalRows')
    const loadedCount   = document.getElementById('loadedCount')
    const loadMoreWrap  = document.getElementById('loadMoreWrap')
    const loadMoreBtn   = document.getElementById('loadMoreBtn')
    const reloadBtn     = document.getElementById('reloadBtn')
    const loadingOverlay= document.getElementById('loadingOverlay')
    const progressText  = document.getElementById('progressText')

    const playerModal   = document.getElementById('playerModal')
    const playerTitle   = document.getElementById('playerTitle')
    const playerSubtitle= document.getElementById('playerSubtitle')
    const playerBody    = document.getElementById('playerBody')
    const closePlayer   = document.getElementById('closePlayer')
    const playerSearch  = document.getElementById('playerSearch')
    const showPlayerBtn = document.getElementById('showPlayerBtn')
    const perkWrap      = document.getElementById('perkWrap')
    const perkStatus    = document.getElementById('perkStatus')
    const perkLink      = document.getElementById('perkLink')

    // Init header refs
    contractShort.textContent = CONTRACT.slice(0,8) + '…' + CONTRACT.slice(-6)
    explorerLink.href = `${API_BASE}/token/${CONTRACT}`

    // ------------------ Helpers ------------------
    function pickDefaultMapId(ids){
      const arr = Array.from(ids).map(Number).filter(n=>!Number.isNaN(n)).sort((a,b)=>b-a)
      return arr.length>=2 ? arr[1] : (arr[0] ?? null)
    }
    function deriveCoinForModal(items, map, selectedCoin, coinFromRow){
      if (selectedCoin && selectedCoin !== 'ALL') return selectedCoin
      if (coinFromRow) return coinFromRow
      const best = items
        .filter(it => String(it._map)===String(map) && parseMsMaybe(it._result)!=null)
        .sort((a,b)=> parseMsMaybe(a._result)-parseMsMaybe(b._result))[0]
      return best ? best._coin : null
    }
    function perkScore(meta){
      const attrs = normalizeAttributes(meta)
      const ignore = new Set(['COINTYPE','COIN','CURRENCY','MAPID','ROUND'])
      return attrs.reduce((sum,a)=> (a.num!=null && a.num>0 && !ignore.has(String(a.label).toUpperCase())) ? sum + a.num : sum, 0)
    }
    // Coin icons & badges
    function coinIcon(coin){
      if(coin==null) return '🪙'
      const k = String(coin).trim().toUpperCase()
      const map = {
        BTC:'₿', WBTC:'₿', TBTC:'₿',
        ETH:'♦', WETH:'♦',
        MATIC:'🟣', POL:'🟣', POLYGON:'🟣',
        LINK:'🔗',
        SOL:'◎',
        BNB:'🟡',
        AVAX:'🔺',
        ADA:'🔵',
        DOGE:'🐕',
        XRP:'✖',
        USDT:'🟩',
        USDC:'🟦',
        DAI:'🟨',
        OP:'🟥',
        ARB:'🟪'
      }
      return map[k] || '🪙'
    }
    function coinBadge(coin){
      const icon = coinIcon(coin)
      const label = (coin==null || String(coin).trim()==='') ? '—' : coin
      return `<span class="inline-flex items-center gap-1.5 px-2 py-1 rounded-md bg-bg-800 border border-slate-700 text-slate-200"><span>${icon}</span><span>${label}</span></span>`
    }

    function byKeyCI(obj, key) {
      if (!obj) return undefined
      if (Array.isArray(obj)) return undefined
      const found = Object.keys(obj).find(k => k.toLowerCase() === key.toLowerCase())
      return found ? obj[found] : undefined
    }

    function getAttr(meta, key) {
      if (!meta) return undefined
      // attributes can be an array of {trait_type, value} or a simple object
      if (Array.isArray(meta.attributes)) {
        const a = meta.attributes.find(x => (x.trait_type||'').toLowerCase() === key.toLowerCase())
        return a ? (a.value ?? a.display_value ?? a.trait_value) : undefined
      }
      if (typeof meta.attributes === 'object' && meta.attributes) {
        const v = byKeyCI(meta.attributes, key)
        if (v !== undefined) return v
      }
      // Sometimes top-level fields exist
      const vTop = byKeyCI(meta, key)
      return vTop
    }

    function parseMsMaybe(val) {
      if (val == null) return null
      const num = Number(val)
      if (Number.isNaN(num)) return null
      return num // expected to be milliseconds; example: 34248 -> 34.248 s
    }

    function fmtMs(ms) {
      if (ms == null) return '—'
      const totalMs = Math.max(0, Math.round(ms))
      const m = Math.floor(totalMs / 60000)
      const s = Math.floor((totalMs % 60000) / 1000)
      const msR = totalMs % 1000
      const pad = n => String(n).padStart(2,'0')
      return `${pad(m)}:${pad(s)}.${String(msR).padStart(3,'0')}`
    }

    function cleanName(nameOrEns, address) {
      if (nameOrEns && typeof nameOrEns === 'string') {
        let n = nameOrEns
        if (n.endsWith('.plyr')) n = n.slice(0, -5)
        if (n.endsWith('.eth'))  n = n.slice(0, -4)
        return n
      }
      if (!address) return 'Unbekannt'
      return address.slice(0,6) + '…' + address.slice(-4)
    }

    function buildPill(labelHtml, value, active) {
      const btn = document.createElement('button')
      btn.className = 'px-3 py-1.5 rounded-full border text-sm whitespace-nowrap ' + (active ? 'bg-primary-600/20 border-primary-600 text-primary-300' : 'bg-bg-800 border-slate-700 hover:border-slate-600 text-slate-200')
      btn.innerHTML = labelHtml
      btn.dataset.value = value
      return btn
    }

    function buildNextUrl(baseUrl, nextParams) {
      if (!nextParams) return null
      const u = new URL(baseUrl)
      Object.entries(nextParams).forEach(([k,v]) => u.searchParams.set(k, v))
      return u.toString()
    }

    function rowHtml(rank, item, bestMs) {
      const owner = item._ownerName || cleanName(item.owner?.ens_domain_name || item.owner?.name, item.owner?.hash)
      const addr  = item.owner?.hash
      const nftUrl= `${API_BASE}/token/${CONTRACT}/instance/${item.token_id || item.id}`
      return `
        <tr class="hover:bg-white/5">
          <td class="px-4 md:px-6 py-3 align-middle text-slate-300">#${rank}</td>
          <td class="px-4 md:px-6 py-3 align-middle">
            <button class="hover:underline text-slate-100 font-medium" data-player="${addr}" data-player-name="${owner}" data-player-coin="${item._coin||''}" data-player-map="${state.selectedMap}">${owner}</button>
          </td>
          <td class="px-4 md:px-6 py-3 align-middle font-mono">${fmtMs(bestMs)}</td>
          <td class="px-4 md:px-6 py-3 align-middle">${coinBadge(item._coin)}</td>
          <td class="px-4 md:px-6 py-3 align-middle"><a href="${nftUrl}" target="_blank" class="text-primary-500 hover:underline">#${item.token_id || item.id}</a></td>
        </tr>`
    }

    function setSubtitle() {
      const coinText = state.selectedCoin === 'ALL' ? 'alle Währungen' : `Währung ${state.selectedCoin}`
      boardSubtitle.textContent = `Runde ${state.selectedMap} • ${coinText}`
    }

    function rebuildCoinPills() {
      coinFilter.innerHTML = ''
      const coins = ['ALL', ...Array.from(state.coins).sort((a,b)=>String(a).localeCompare(String(b)))]
      coins.forEach(c => {
        const labelHtml = c === 'ALL' ? '∑&nbsp;Alle' : `<span class="mr-1">${coinIcon(c)}</span>${c}`
        const btn = buildPill(labelHtml, c, c === state.selectedCoin)
        btn.addEventListener('click', () => {
          state.selectedCoin = c
          rebuildCoinPills()
          renderLeaderboard()
        })
        coinFilter.appendChild(btn)
      })
    }

    function rebuildMapSelect() {
      const arr = Array.from(state.mapids).map(x => Number(x)).filter(n => !Number.isNaN(n)).sort((a,b)=>b-a)
      mapSelect.innerHTML = arr.map(x => `<option value="${x}">${x}</option>`).join('')
      if (!state.selectedMap && arr.length) state.selectedMap = pickDefaultMapId(state.mapids)
      mapSelect.value = state.selectedMap ?? ''
      setSubtitle()
    }

    // ----- Leaderboard computation (pure, testable)
    function computeLeaderboardFrom(items, selectedMap, selectedCoin) {
      const bestMap = new Map()
      const mapFilter = String(selectedMap)
      for (const it of items) {
        if (String(it._map) !== mapFilter) continue
        if (selectedCoin !== 'ALL' && String(it._coin) !== String(selectedCoin)) continue
        const owner = it.owner?.hash || '0x0'
        const key = (selectedCoin === 'ALL') ? `${owner}|${String(it._coin)}` : owner
        const currentMs = parseMsMaybe(it._result)
        if (currentMs == null) continue
        const prev = bestMap.get(key)
        if (!prev || currentMs < prev.ms) bestMap.set(key, { ms: currentMs, item: it })
      }
      return Array.from(bestMap.values()).sort((a,b)=>a.ms-b.ms)
    }

    function computeLeaderboard() {
      return computeLeaderboardFrom(state.items, state.selectedMap, state.selectedCoin)
    }

    function renderLeaderboard() {
      setSubtitle()
      const rows = computeLeaderboard()
      totalRows.textContent = rows.length
      loadedCount.textContent = state.items.length
      tableBody.innerHTML = rows.map((r, i) => rowHtml(i+1, r.item, r.ms)).join('')

      // wire player buttons
      tableBody.querySelectorAll('button[data-player]').forEach(btn => {
        const coin = btn.dataset.playerCoin || null
        const map  = btn.dataset.playerMap || null
        btn.addEventListener('click', () => openPlayer(btn.dataset.player, btn.dataset.playerName, coin, map))
      })
    }

    // ----- Perk NFT helpers
    function normalizeAttributes(meta){
      const out = []
      if (!meta) return out
      const push = (label, value) => {
        const num = (value==null? null : Number(value))
        out.push({label:String(label), value, num: Number.isFinite(num) ? num : null})
      }
      if (Array.isArray(meta.attributes)){
        for (const a of meta.attributes){
          const label = a.trait_type ?? a.label ?? a.name ?? 'Trait'
          const val = a.value ?? a.display_value ?? a.trait_value ?? null
          push(label, val)
        }
      } else if (meta.attributes && typeof meta.attributes === 'object'){
        for (const [k,v] of Object.entries(meta.attributes)) push(k, v)
      }
      return out
    }

    function renderPerkCard(item, context){
      if (!item) { perkStatus.textContent = 'Kein Perk‑NFT gefunden.'; perkLink.classList.add('hidden'); perkWrap.innerHTML=''; return }
      const id = item.token_id || item.id
      perkLink.href = `${API_BASE}/token/${PERK_CONTRACT}/instance/${id}`
      perkLink.classList.remove('hidden')
      const ctx = []
      if (context && context.map != null) ctx.push(`Runde ${context.map}`)
      if (context && context.coin) ctx.push(String(context.coin))
      perkStatus.textContent = `Token #${id}${ctx.length? ' • '+ctx.join(' • '):''}`
      const meta = item.metadata || {}
      const attrs = normalizeAttributes(meta)
        .filter(x => x.num != null && x.num > 0)
        .sort((a,b)=> b.num - a.num)
      if (!attrs.length){ perkWrap.innerHTML = '<div class="text-slate-400 text-sm">Keine Perks (>0) vorhanden.</div>'; return }
      perkWrap.innerHTML = attrs.map(a => `
        <div class="glass rounded-xl p-3 border border-slate-700">
          <div class="text-xs text-slate-400">${a.label}</div>
          <div class="text-2xl font-bold">${a.num}</div>
        </div>`).join('')
    }

    async function safeJson(url){
      try{ const r = await fetch(url); if(!r.ok) return null; return await r.json() }catch{ return null }
    }

    async function findPerkInstanceForOwner(address, map, coin){
      const base = `${API_BASE}/api/v2/tokens/${PERK_CONTRACT}/instances`
      let nextUrl = `${base}?items_count=200`
      const addr = (address||'').toLowerCase()
      let guard = 0
      let best = null
      let bestScore = -1
      while (nextUrl && guard < 50){
        const j = await safeJson(nextUrl)
        if (!j) break
        const items = j.items || j.data || []
        for (let it of items){
          const h = (it.owner?.hash||'').toLowerCase()
          if (!h || h === ZERO || h !== addr) continue
          if (!it.metadata && it.token_id){
            const j2 = await safeJson(`${API_BASE}/api/v2/tokens/${PERK_CONTRACT}/instances/${it.token_id}`)
            if (j2 && (j2.item || j2)) it = j2.item || j2
          }
          const meta = it.metadata || {}
          const coinMeta = (getAttr(meta, 'cointype') ?? getAttr(meta,'coin') ?? getAttr(meta,'currency'))
          const mapMeta  = (getAttr(meta, 'mapid') ?? getAttr(meta,'round'))
          if (coin && String(coinMeta||'').toUpperCase() !== String(coin).toUpperCase()) continue
          if (map != null && String(mapMeta) !== String(map)) continue
          const score = perkScore(meta)
          if (score > bestScore){ bestScore = score; best = it }
        }
        nextUrl = buildNextUrl(base, j.next_page_params)
        guard++
      }
      return best
    }

    async function loadPerkNft(address, map, coin){
      perkWrap.innerHTML = ''
      perkStatus.textContent = 'Lade Perk‑NFT…'
      perkLink.classList.add('hidden')
      if (!address || address.toLowerCase() === ZERO){
        perkStatus.textContent = 'Ignoriere Zero‑Address.'
        return
      }
      const item = await findPerkInstanceForOwner(address, map, coin)
      if (!item){ 
        perkStatus.textContent = `Kein Perk‑NFT für Runde ${map ?? '—'}${coin? ' • '+coin:''} gefunden.`
        perkWrap.innerHTML = ''
        perkLink.classList.add('hidden')
        return 
      }
      renderPerkCard(item, {map, coin})
    }

    async function openPlayer(address, name, coinFromRow, mapFromRow) {
      const list = state.items.filter(it => it.owner?.hash === address)
      const human = cleanName(name, address)
      playerTitle.textContent = human
      playerSubtitle.textContent = `${address}`
      const rows = list
        .map(it => ({ map: it._map, coin: it._coin, ms: parseMsMaybe(it._result), id: it.token_id || it.id }))
        .filter(r => r.ms != null)
        .sort((a,b)=> a.ms-b.ms)
      playerBody.innerHTML = rows.map(r => `
        <tr>
          <td class="px-4 md:px-6 py-2">${r.map}</td>
          <td class="px-4 md:px-6 py-2">${coinBadge(r.coin)}</td>
          <td class="px-4 md:px-6 py-2 font-mono">${fmtMs(r.ms)}</td>
          <td class="px-4 md:px-6 py-2"><a target="_blank" class="text-primary-500 hover:underline" href="${API_BASE}/token/${CONTRACT}/instance/${r.id}">#${r.id}</a></td>
        </tr>`).join('') || `
        <tr><td colspan="4" class="px-4 md:px-6 py-6 text-slate-400">Keine Zeiten gefunden.</td></tr>`
      const mapForPerk = mapFromRow ?? state.selectedMap
      const coinForPerk = deriveCoinForModal(list, mapForPerk, state.selectedCoin, coinFromRow)
      await loadPerkNft(address, mapForPerk, coinForPerk)
      playerModal.classList.remove('hidden')
    }

    closePlayer.addEventListener('click', ()=> playerModal.classList.add('hidden'))
    playerModal.addEventListener('click', (e)=> { if (e.target === playerModal) playerModal.classList.add('hidden') })
    showPlayerBtn.addEventListener('click', () => {
      const q = playerSearch.value.trim().toLowerCase()
      if (!q) return
      const hit = state.items.find(it => {
        const name = cleanName(it.owner?.ens_domain_name || it.owner?.name, it.owner?.hash).toLowerCase()
        return name === q || name.includes(q) || (it.owner?.hash||'').toLowerCase() === q
      })
      if (hit) openPlayer(hit.owner.hash, cleanName(hit.owner?.ens_domain_name || hit.owner?.name, hit.owner?.hash), null, state.selectedMap)
    })

    // Map navigation
    mapSelect.addEventListener('change', (e) => { state.selectedMap = e.target.value; renderLeaderboard() })
    prevMapBtn.addEventListener('click', ()=> stepMap(-1))
    nextMapBtn.addEventListener('click', ()=> stepMap(+1))
    function stepMap(delta){
      const arr = Array.from(state.mapids).map(Number).filter(n=>!Number.isNaN(n)).sort((a,b)=>a-b)
      const idx = arr.indexOf(Number(state.selectedMap))
      const next = arr[idx + delta]
      if (next != null) { state.selectedMap = next; mapSelect.value = next; renderLeaderboard() }
    }

    reloadBtn.addEventListener('click', () => { resetAndLoad() })
    loadMoreBtn.addEventListener('click', () => { if (state.nextUrl) loadMore() })

    function resetAndLoad(){
      state.items = []
      state.mapids.clear()
      state.coins.clear()
      state.nextUrl = null
      state.baseListUrl = null
      state.selectedMap = null
      state.selectedCoin = 'ALL'
      tableBody.innerHTML = ''
      coinFilter.innerHTML = ''
      mapSelect.innerHTML = ''
      totalRows.textContent = '0'
      loadedCount.textContent = '0'
      loadMoreWrap.classList.add('hidden')
      playerModal.classList.add('hidden')
      start()
    }

    // ------------------ Fetch + ingest ------------------
    async function start(){
      loadingOverlay.classList.remove('hidden')
      progressText.textContent = ''

      // 1) Token info (name)
      try {
        const rTok = await fetch(`${API_BASE}/api?module=token&action=getToken&contractaddress=${CONTRACT}`)
        if (rTok.ok) {
          const j = await rTok.json()
          const name = j?.result?.name || 'Collection'
          document.getElementById('tokenName').textContent = name
        }
      } catch {}

      // 2) Load first page of instances (API v2)
      state.baseListUrl = `${API_BASE}/api/v2/tokens/${CONTRACT}/instances`
      const firstUrl = new URL(state.baseListUrl)
      firstUrl.searchParams.set('items_count', '100')
      await loadFrom(firstUrl.toString())

      if (!state.items.length) {
        progressText.textContent = 'Keine NFTs gefunden. Prüfe Contract & API.'
      }
      loadingOverlay.classList.add('hidden')
    }

    async function loadFrom(url){
      try{
        const r = await fetch(url)
        if (!r.ok) throw new Error(`HTTP ${r.status}`)
        const j = await r.json()
        const items = j?.items || j?.data || []
        ingest(items)
        loadedCount.textContent = state.items.length
        // next page
        state.nextUrl = buildNextUrl(state.baseListUrl, j?.next_page_params)
        if (state.nextUrl) {
          if (state.items.length < 2000) {
            progressText.textContent = `Lade weiter… (${state.items.length})`
            await loadFrom(state.nextUrl)
          } else {
            loadMoreWrap.classList.remove('hidden')
            progressText.textContent = `Weitere Seiten verfügbar.`
          }
        } else {
          loadMoreWrap.classList.add('hidden')
          progressText.textContent = 'Fertig.'
        }
        rebuildMapSelect(); rebuildCoinPills(); renderLeaderboard()
      } catch(e){
        console.error(e)
        progressText.textContent = 'Fehler beim Laden: ' + (e?.message||e)
      }
    }

    async function loadMore(){
      if (!state.nextUrl) return
      loadingOverlay.classList.remove('hidden')
      await loadFrom(state.nextUrl)
      loadingOverlay.classList.add('hidden')
    }

    function ingest(items){
      for (const it of items) {
        try {
          const meta = it?.metadata || {}
          const result = parseMsMaybe(getAttr(meta, 'Result'))
          const coin   = getAttr(meta, 'cointype') ?? getAttr(meta, 'coin') ?? getAttr(meta, 'currency')
          const mapid  = getAttr(meta, 'mapid') ?? getAttr(meta, 'round')
          if (mapid != null) state.mapids.add(Number(mapid))
          if (coin  != null && String(coin).trim() !== '') state.coins.add(String(coin))
          it._result = result
          it._coin   = coin ?? '—'
          it._map    = mapid ?? '—'
          if (it.owner) {
            it._ownerName = cleanName(it.owner.ens_domain_name || it.owner.name, it.owner.hash)
          }
          state.items.push(it)
        } catch(err) {
          console.warn('skip item', err)
        }
      }
      if (!state.selectedMap && state.mapids.size) {
        state.selectedMap = pickDefaultMapId(state.mapids)
      }
    }

    // ------------------ Tiny Tests (console) ------------------
    function runTests(){
      try {
        console.group('%cTests','color:#22D3EE')
        // Bestehende Tests – nicht ändern
        console.assert(parseMsMaybe('34248')===34248,'parseMsMaybe failed')
        console.assert(fmtMs(34248)==='00:34.248','fmtMs failed')
        console.assert(coinIcon('LINK')==='🔗','coinIcon LINK failed')
        const mockOwner = (h)=>({owner:{hash:h}})
        const mock = [
          {_map:1,_coin:'LINK',_result:1000,...mockOwner('0xA')},
          {_map:1,_coin:'ETH', _result: 900,...mockOwner('0xA')},
          {_map:1,_coin:'ETH', _result:1100,...mockOwner('0xB')},
          {_map:2,_coin:'ETH', _result: 500,...mockOwner('0xA')}
        ]
        let out = computeLeaderboardFrom(mock,1,'ALL')
        console.assert(out.length===2,'ALL should allow duplicate owners by coin')
        out = computeLeaderboardFrom(mock,1,'ETH')
        console.assert(out.length===2 && out[0].ms===900,'ETH best per owner failed')
        // Attribute‑Parsing
        const attrs = normalizeAttributes({attributes:[{trait_type:'A',value:'3'},{trait_type:'B',value:'0'},{trait_type:'C',value:'7'}]})
        const nums = attrs.filter(x=>x.num!=null).map(x=>x.num)
        console.assert(nums.includes(3) && nums.includes(7),'normalizeAttributes numeric parse failed')

        // Zusätzliche Tests (neu)
        // buildNextUrl
        const built = buildNextUrl('https://x/y', {page:'2',items_count:'100'})
        console.assert(built.includes('page=2') && built.includes('items_count=100'), 'buildNextUrl failed')
        // computeLeaderboardFrom: ALL vs einzelner Coin gleiche Länge bei disjunkten Coins
        const mock2 = [
          {_map:1,_coin:'AAA',_result:100,...mockOwner('0x1')},
          {_map:1,_coin:'BBB',_result:200,...mockOwner('0x1')}
        ]
        const allL = computeLeaderboardFrom(mock2,1,'ALL').length
        const aL = computeLeaderboardFrom(mock2,1,'AAA').length
        const bL = computeLeaderboardFrom(mock2,1,'BBB').length
        console.assert(allL===2 && aL===1 && bL===1, 'computeLeaderboardFrom length mismatch')

        // Default map selection tests
        console.assert(pickDefaultMapId(new Set([1,2,3]))===2,'pickDefaultMapId second latest failed')
        console.assert(pickDefaultMapId(new Set([7]))===7,'pickDefaultMapId single failed')
        // deriveCoinForModal tests
        const lc = [
          {_map:9,_coin:'ETH',_result:1000},
          {_map:9,_coin:'BTC',_result:900},
          {_map:8,_coin:'LINK',_result:800}
        ]
        console.assert(deriveCoinForModal(lc,9,'ALL',null)==='BTC','deriveCoinForModal best-in-map failed')
        console.assert(deriveCoinForModal(lc,9,'ETH',null)==='ETH','deriveCoinForModal selectedCoin override failed')
        console.groupEnd()
      } catch(e) { console.warn('Tests error', e) }
    }

    // Kickoff
    runTests()
    start()
  })()
  </script>
</body>
</html>
